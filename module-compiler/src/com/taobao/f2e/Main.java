package com.taobao.f2e;

import org.apache.commons.cli.*;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.regex.Pattern;

/**
 * invoke module compiler for kissy
 *
 * @author yiminghe@gmail.com
 * @since 2011-01-18
 */
public class Main {

    static String DEP_PREFIX = "/*Generated By KISSY Module Compiler*/\n" +
            "KISSY.config('modules',{\n";

    static String DEP_SUFFIX = "\n});";

    /**
     * packages.
     */
    private Packages packages = new Packages();

    /**
     * exclude pattern for modules.
     */
    private Pattern excludePattern;

    /**
     * stack of visited modules to detect circular dependency
     */
    private ArrayList<String> modulesVisited = new ArrayList<String>();

    /**
     * requires mods name for current application.
     */
    private String require = null;

    /**
     * combined mods 's code 's output file path.
     */
    private String output = "";//"d:/code/kissy_git/kissy-tools/module-compiler/test/kissy/combine.js";

    /**
     * combined mods 's code 's output file encoding.
     */
    private String outputEncoding = "utf-8";

    /**
     * all processed modules.
     */
    protected ArrayList<Module> modules = new ArrayList<Module>();

    /**
     * whether overwrite module's file with module name added.
     */
    private boolean fixModuleName = false;

    /**
     * whether output dependency file path.
     */
    private String outputDependency = null;

    /**
     * dependencies
     */
    private ArrayList<String> dependencies = new ArrayList<String>();

    public void setExcludePattern(Pattern excludePattern) {
        this.excludePattern = excludePattern;
    }

    public void setOutputDependency(String outputDependency) {
        this.outputDependency = outputDependency;
    }

    public void setFixModuleName(boolean fixModuleName) {
        this.fixModuleName = fixModuleName;
    }

    public void setOutput(String output) {
        this.output = output;
    }

    public Packages getPackages() {
        return packages;
    }

    public void setOutputEncoding(String outputEncoding) {
        this.outputEncoding = outputEncoding;
    }

    public void setRequire(String require) {
        this.require = require;
    }

    public void run() {
        long start = System.currentTimeMillis();

        combineRequire(require);

        ArrayList<String> combinedFiles = new ArrayList<String>();
        StringBuilder finalCodes = new StringBuilder();

        for (Module m : modules) {
            combinedFiles.add(m.getName());
            finalCodes.append(m.getCode());
        }

        String re = "/*\n Combined modules by KISSY Module Compiler: \n\n " +
                ArrayUtils.join(combinedFiles.toArray(new String[combinedFiles.size()]), "\n ")
                + "\n*/\n\n" + finalCodes.toString();

        if (output != null) {
            FileUtils.outputContent(re, output, outputEncoding);
            System.out.println("success generated: " + output);
        } else {
            System.out.println(re);
        }

        if (outputDependency != null && dependencies.size() != 0) {


            String allRs = "";
            for (String r : dependencies) {
                if (r.startsWith("#")) {
                    allRs += "," + r.substring(1);
                } else {
                    allRs += ",'" + r + "'";
                }
            }
            re = DEP_PREFIX + "'" + require + "': {requires: [" +
                    allRs.substring(1) + "]}" + DEP_SUFFIX;
            FileUtils.outputContent(re, outputDependency, outputEncoding);
            System.out.println("success generated: " + outputDependency);
        }

        System.out.print("duration: " + (System.currentTimeMillis() - start));
    }

    private void addDependency(String requiredModuleName) {
        if (!dependencies.contains(requiredModuleName)) {
            dependencies.add(requiredModuleName);
        }
    }

    /**
     * x -> a,b,c : x depends on a,b,c
     * add a,b,c then add x to final code buffer
     *
     * @param requiredModuleName module name required
     */
    private void combineRequire(String requiredModuleName) {

        // if css file, do not combine with js files
        // !TODO generate a combined css file
        if (requiredModuleName.endsWith(".css") ||
                // conditional loader
                requiredModuleName.startsWith("#")) {
            this.addDependency(requiredModuleName);
            return;
        }

        // if specify exclude this module, just return
        if (excludePattern != null &&
                excludePattern.matcher(requiredModuleName).matches()) {
            this.addDependency(requiredModuleName);
            return;
        }

        Module requiredModule = packages.getModule(requiredModuleName);

        if (!requiredModule.isModuleExists()) {
            System.out.println("warning  module's file not found: " + requiredModuleName
                    + ": " + requiredModule.getFullpath());
            this.addDependency(requiredModuleName);
            return;
        }

        if (!requiredModule.isValidFormat()) {
            System.out.println("!! format or syntax error in module: " + requiredModule.getFullpath());
            System.exit(1);
        }

        //x -> a,b,c
        //a -> b
        //when requiredModuleName=x and encounter b ,just return
        //reduce redundant parse and recursive
        if (modules.contains(requiredModule)) {
            return;
        }

        if (modulesVisited.contains(requiredModuleName)) {
            String error = "cyclic dependence: " +
                    ArrayUtils.join(modulesVisited.toArray(new String[modulesVisited.size()]),
                            ",") + "," + requiredModuleName;
            //if silence ,just return
            System.out.println("error: " + error);
            System.exit(1);
            return;
        }

        //mark as start for cyclic detection
        modulesVisited.add(requiredModuleName);

        requiredModule.completeModuleName(fixModuleName);

        String[] requires = requiredModule.getRequires();

        for (String require : requires) {
            combineRequire(require);
        }

        //remove mark for cyclic detection
        modulesVisited.remove(modulesVisited.size() - 1);

        modules.add(requiredModule);
    }


    public static void commandRunnerCLI(String[] args) throws Exception {

        Options options = new Options();
        options.addOption("encodings", true, "baseUrls 's encodings");
        options.addOption("baseUrls", true, "baseUrls");
        options.addOption("require", true, "require");
        options.addOption("excludeReg", true, "excludeReg");
        options.addOption("output", true, "output");
        options.addOption("v", "version", false, "version");
        options.addOption("outputEncoding", true, "outputEncoding");
        options.addOption("outputDependency", true, "outputDependency");
        options.addOption("fixModuleName", true, "fixModuleName");

        // create the command line parser
        CommandLineParser parser = new GnuParser();
        CommandLine line;

        try {
            // parse the command line arguments
            line = parser.parse(options, args);
        } catch (ParseException exp) {
            System.out.println("Unexpected exception:" + exp.getMessage());
            return;
        }

        if (line.hasOption("v")) {
            System.out.println("KISSY Module Compiler 1.3.1");
            return;
        }

        Main m = new Main();

        Packages packages = m.getPackages();

        String encodingStr = line.getOptionValue("encodings");
        if (encodingStr != null) {
            packages.setEncodings(encodingStr.split(","));
        }

        String baseUrlStr = line.getOptionValue("baseUrls");
        if (baseUrlStr != null) {
            packages.setBaseUrls(baseUrlStr.split(","));
        }

        String fixModuleName = line.getOptionValue("fixModuleName");
        if (fixModuleName != null) {
            m.setFixModuleName(true);
        }

        m.setRequire(line.getOptionValue("require"));

        String excludeReg = line.getOptionValue("excludeReg");
        if (excludeReg != null) {
            m.setExcludePattern(Pattern.compile(excludeReg));
        }

        m.setOutput(line.getOptionValue("output"));

        String outputEncoding = line.getOptionValue("outputEncoding");
        if (outputEncoding != null) {
            m.setOutputEncoding(outputEncoding);
        }

        m.setOutputDependency(line.getOptionValue("outputDependency"));

        m.run();

    }

    public static void main(String[] args) throws Exception {
        System.out.println("current path: " + new File(".").getAbsolutePath());
        System.out.println("current args: " + Arrays.toString(args));
        commandRunnerCLI(args);
    }
}
